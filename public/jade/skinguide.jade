// UNCLASSIFIED

extends site
append site_help
	:markdown
		See also the companion [api reference](/api.jade) and the [programmers ref manual](/shares/doc/totem/index.html).
append site_parms
	- view = "Min"
append site_body

	#fit.Introduction
		:markdown
			When a client requests a X.view, **#{nick}** renders this view with the jade skin associated with X.  [Jade](http://jade-lang.com/tutorial/)
			skins deliver html to the requesting client via a highlevel (js compatible) markdown (similar to the typescript if angularjs, but 
			more powerful).  **#{nick}** retrieves the skin for a X.view request by first attempting to find a jade skinning
			engine named X in its [jade engines](/engine.jade).  If no skin is found, **#{nick}** retrieves the skin from its 
			internal jade skin area. 

			Skins are built on framework skins.  Frameworks provide a parms, a head, and a body block which are extended 
			by a parent skin.  Any skin is free to become a framework by simplying defining its own parms, head, and body blocks.				
			Tthe [home skin](/home.jade), for example, extends the [site framework](/site.jade), which extends 
			the [base framework](/base.jade), which then extends the [layout framework](/layout.jade).

			Many views -- for example, the  D3 [force](/force.jade), [cluster](/cluster.jade), [cpack](/cpack.jade), [treefan](/treefan.jade), [treemap](/treemap.jade), [sankey](/sankey.jade), 
			[chords](/chords.jade), the [plot](/plot.jade) and others [map](/map.jade), [files](/files.jade)) -- employ the layout framework, and can accept query parameters themselves (see, 
			for example, the [D3 plot](/plot.jade)).

			A parent skin extends a framework skin following the **parms-head-body** pattern:

				extends FRAMEWORK
				append FRAMEWORK_head
					CONTENT
				append FRAMEWORK_parms
					- parm = value
					- parm = value
					- parm = value
				append FRAMEWORK_body
					CONTENT

			where CONTENT is more jade.

	#folder.Frameworks(dock="left")
		#fit.layout
			:markdown
				Provides a base layout framework with parameters:
				
					banner = site banner
					start = div name to start skinning
					math = [false | true] mathjax plugin 
					highlight = [zenburn | ...] code styling theme 
					capture = [false | true] to add screen capture button
					inline = [/PATH/FILE.type &w=width &h=height] embed file with derived attributes

		#fit.base
			:markdown
				The base framework provides a technology agnostic interface and accepts parameters:
				
					tech = extjs | jquery | dojo | reveal | voxel | scene | three | cesium | joint | d3 | nada
					locale = [en | fr | de | ...] language plugin 
					holdoff = name on button to load this skin 
					holdoff = [skin,skin, ...] skins to load via accordion

				extjs parameters:
				
					carousel = [false | true] image plugin
					theme = [crisp | neptune | aria | gray | ...] styling
					charting = [true | false] data visualization plugin
					locale = [en | fr | de | ...] language plugin 
					holdoff = name on button to load this skin 
					holdoff = [skin,skin, ...] skins to load via accordion

				three parameters:
				
					effect = AnaglyphEffect | special effect

				voxel parameters:
				
					game = paint | name of game

				jquery parameters:
				
					grid = DataTable | W2UI | jqGrid | ...
					image = Darkroom | Camen | Vide | Fabric | ...
					pivot = Isotope | elFinder | apy-X | ...
					themer = false | true
					password = false | true

				reveal parameters:
				
					theme = [default | ...] styling  
					classif = classification banner

				d3 parameters:
				
					map =  | world | usa | ...

				joint parameters:
				
					entry =  | ...
					host = aws | geohub | me | win
					width = 750
					height = 500
					src = Python1 | ...

		#fit.site
			:markdown
				Extends the base framework to provide a standard site skinning framework with parameters:
					parms = {option1: menu1, option2: menu2, ...} dropdown skinning options 
					dock = [left | right | top | bottom] folder docking style 
					dims = width,height maximum widget dimensions 
					view = [Home | Kiss | Engr | Min | Basic | Nada, ...] site style
					page = maximum grid rows
					goto = tab to activate
					help = extra html help
					pulse = system health refresh rate (in seconds)
	
	#fit.Skin.Layouts

		:markdown
			Skins are layed-out as follows:

				#WIDGET.NAME(...)
					#WIDGET.NAME(...)

					:
					:

				#WIDGET.NAME(...)
					#WIDGET.NAME(...)

					:
					:

				TAG(...) CONTENT

				ishtml
					widget-free html

				inline(src="/PATH/FILE.TYPE", w="WIDTH", h="HEIGHT", g="GOTO", a="ATTRIBUTE", s="CSS")

				:FILTER
					CONTENT

				code.LANGUAGE.
					CONTENT

				script.
					CONTENT

			where  

			+ FRAMEWORK specifies the desired skinning framework (see Introduction.Frameworks)

			+ NAME uniquely identifies this widget

			+ FILTER is [markdown](https://github.com/jstransformers) | markdown-it | supermarked | babel | less | coffee-script

			+ (...) represents a list of KEY=VALUE attributes

			+ COLON represents TAGs or [Jade program flow](http://jade-lang.com/tutorial/)

			+ CONTENT include tag-specific content (e.g. markdown, $ mathjax $,  \$$ mathjax \$$ text, javascript, etc)

			+ inline embeds the requested FILE, its file ATTRIBUTE, and a hyperlink 
			customized for TYPE = db, py | js | mat | ... or TYPE = jpg | png | ico | ... files.

			+ a WIDGET falls into one of the following categories:  

				+ aggregator: **content** | **folder** | **accordion** | **window** | **border** | **post**
				+ layout: **anchor** | **fit** | **hbox** | **vbox** | **box** | **table** | **column**
				+ terminal: **grid** | **form** | **pivot** | **find** | **hold**
				+ cartesian chart: **bar** | **bar3d** | **candlestick** | **line** | **scatter**
				+ polar chart: **gauge** | **pie** | **pie3d** | **radar**
				+ surface chart: (reserved)
				+ raster chart: **image** (experimental)

			For example, the tabs in a **folder** (or the sections in an **accordion**, or the regions
			within a **border**) container are introduced by indented layouts, display or containers. 
			The HTML and WIDGETs indented under a terminal form the terminal's tool-tips.  

			A **post** widget can be used explictly or implictly:

				#post.NAME(path="/SKIN.jade?src=SOURCE", ...)
				#SKIN.NAME(path="SOURCE")

			The **hold** widget:

				#hold.FIELD(path="SOURCE",cols="DISPLAY,VALUE,...")

			holds data for comboboxes (with given DISPLAY VALUE cols) associated with the
			FIELD.combo cols used in other terminals.

			A widget's SOURCE **path** can reference a dataset, static data, skinning options, or (if a **post**)
			a view, a file, or an area index:
			+	/DATASET.db?QUERY
			+	[{key:val,...}]
			+	{key:display,...} 
			+	/SKIN.view
			+	/FILE.TYPE?QUERY
			+	/AREA/

			The optional QUERY can contain #{nick}-context expressions:
			+ \\#{KEY ... F(...) ...}

			where KEY and methods **F()** are defined in**Context Keys**.  The QUERY
			may also contain client-context (dataset linking) expressions:
			+ ${xs( 'N' ).KEY ... x.KEY ... ds( 'N' ).KEY ... d.KEY}

			where xs('N') sets **x** to key the active record of dataset N, and ds('N') sets **d** to
			key the properties of dataset N.

	#fit.Widget.Attributes

		:markdown
			Source Attributes

				path = "SOURCE"
				class = "unique widget name"
				key = "key name of unique record id" (defaults to "ID")
				index = "KEY, expression, expression as KEY, ..." key indexer and creater (defaults to "*")

			Display Attributes

				dims = "WIDTH,HEIGHT" maximum widget dimensions
				sorts = "field, field, ..." sort columns
				title = "header" title
				region = north | south | east | west | center border region
				page = number of records to display 
				refresh = data store refresh rate (in seconds).  ## in path replaced by refresh count.
				plugins = "crbXCRF0" editor(cell/row), selector(boX/Column/Row), Filter(F), disable(0)

			Field Attributes

				cols = "KEY.type.label.sum.tip, KEY*, KEY*count, ... " field list
				cols = "group(KEY,group(KEY, ...), ...), ..." field groups
				cols = "Pivot(NodeID,NodeCount,KEY,KEY, ...), ..." field pivots
				pivots = "KEY,KEY,..." pivot shortcut

			where
			>	KEY* matches "KEY0, KEY1, ..." in the **Parms** dataset  
			>	KEY*count returns "KEY0, KEY1, ... KEY[count-1]" in the **Parms** dataset  
			>	label display label  
			>	sum	aggregates by sum | min | max | average | count | any | all | prod | nills | uti  

			Field Types
			+	integer: int | bigint | tinyint | autonum | auto  
			+	binary: checkbox | boolean  
			+	text: varchar | text | html | xtextarea  
			+	special: file | svg | geometry | combo  
			+	numeric: number | float | double | percent | money  
			+	date: date | datetime | mediumdate | defaultdate | iso8601long | iso8601short |shortdate | longdate | fulldatetime | monthday | shorttime | longtime | sortabledatetime | universalsortabledatetime | yearmonth  
			+	icon: ##... (make icon list from class img-Action-value[0, 1, ...])

			Capatalized types flag a read only field (mandatory for fields derived by selects).
			The first character abbreviates a type. **Due to browser bugs (1) an html grid field may revert to xtextarea and (2) a numeric 
			form field may revert to text.**

			Grid Switches
			
				shifts	allow grid cell shifting
				calc	allow grid cell expressions
				crush	allow minimization
				refresh	manual data store refresher
				hide	render but dont show
				disable disable data entry
				notes	include data notepad within help 
				joins	include data joins within help 
				save	save view state (experimental)
				kiss	display simple linking cues
				nowrap	hides header menu
				summary = min | max | average | count | sum | util | any | all | prod | nills row aggregator

			When the **calc** switch is provided, grids will evaluate =prefixed cells as follows:
			>	=F text specifies font F=RGBKO... for text  
			>	=C text specifies cell style C=0...9 for text  
			>	=/BLOG.jade	embeds the BLOG by its skin name  
			>	=JS expression 

			where a JS expression can include:
			>	r,c returns the current grid row,col index  
			>	d.COLUMN returns grid value at COLUMN in current row  
			>	a[ROW].COLUMN returns grid value at ROW and COLUMN  
			>	f.FUNCTION addresses a MathJS function

			Content Attributes
			
				icons = path to icon resources
				start = widget to start skinning defaults to "content"
				query = parameters to save in query variable

			Chart Attributes
			
				plot = bar,column,scatter,info,pie,radar,xgrid,ygrid,[xmin,xmax,ymin,ymax]

			Folder Attributes
			
				active = folder tab to make active

			Menu Attributes
			
				top = "MENU" docked to top
				left = "MENU" docked to left
				right = "MENU" docked to right
				bottom = "MENU" docked to bottom
				head = "MENU" docked to header

			where:
			+	MENU: WIDGET, ... GROUP(SOURCE,WIDGET,SPECIAL,ACTION,LOADER,BREAK ...), ...   
			+	WIDGET: combo widget with cols=Name,Value fields  
			+	SPECIAL: Search | Print | Refresh | Help | Capture | Save | Status | Delta  
			+	ACTION: Insert | Update | Delete | Select | Execute  
			+	LOADER: $stores | $uploads | $positives | $negatives  
			+	BREAK: |

	#fit.Workflows
	
		#folder(left)
			#fit.Introduction
				:markdown
					## Models
					A workflow defines a network of systems.  A system (aka machine, engine or application) can be a 
					discrete block (triggered or sampled), a state machine, or a petri net.  Each system has a URL identifing 
					the path to a restful application that sinks and sources event tokens.  The [api](/api.jade) explains
					the workflow engine interface.  Workflows can be defined using the [workflow editor](/workflow.jade).
					
					Engine stats (event rates, queueing delay, utilization, drops, etc), machine states, and petri tokens are
					logged as the client steps/advances a workflow with the specified simulation options (number of steps, 
					step size, stats snapshot period).
					
					Workflows are constructed using the system skins, and are compiled, linked and executed at the client
					using the [workflow editor](/workflow.jade).  A workflow skin will thus look like:
					
						#system.label(inputs="link,link,...",outputs="link,link,...")  
							#system.label(inputs="link,link,...",outputs="link,link,...")  
							#system.label(inputs="link,link,...",outputs="link,link,...")  
					
					where i/o ports can accept/produce either simple or N-fold threads:
					
						input link = name|N|system|name  
						output link = name|N
					
					## Threaded Models
					System i/o ports (and their corresponding i/o event tokens) can be either simple or N-fold threaded.
					Whereas simple ports are sampled, threaded ports are triggered.  In an algorithm chain of, say, 3 systems, 
					with 5, 10, and 2 threaded output ports, there are 5*10*2=100 total execution threads that can be shared
					(hyper-threaded) among K processing cores (if the server implements, say, K=4 processing cores, then 
					no more than 100/4=25 threads are impacted by a single failing thread).
					
					## Application Interface
					Each system application supports TAUINIT, TAUSTEP, TAUKILL, and TAUREAD (restful PUT, POST, DELETE, GET) to
					program, advance, deallocate and read an engine given itau, otau and state parameters: 
					
						itau = [event1, event2, ...] events being sinked to inputs ports 1,2, ... 
						otau = [event1, event2, ...] events being sourced from output ports 1,2, ...
						state = {simulation step count, relative simulation time, depth of queue, drops from queue, 
								engine index, as well as a port reset, port name, and port index when stepping i/o threads}.
 			
			#fit.Attributes
				:markdown
					## All systems [default value]
				
						run [false] autorun simulation with the specified simulation options
						stats = "name" ["stats"] of simulation options in simoptions.db
						buffers = N [0] reserved
				
					## Discrete systems
				
						inputs = "link, link, ..." [""] input ports
						outputs = "link, link, ..." [""] output ports
				
					where link = "name|N|system|name" defines an N-threaded or N=0 simple port.
				
					## State machines:
				
						routes = "route, route, ..." [""] are the routes for a state machine
				
					where route = "fromState | toState | condition | exit | entry" [""] defines from-to machine states, condition code and from state exit-entry code (condition=start to define initial state).
				
					## Petri nets:
				
						markers	= "transition, transition, ..." [""] are the transitions for a petri net
				
					where:
				
						transition = "fromPlaces || transition || toPlaces" defines from-to places and transition to take-deposit petri net tokens ("n|k|..." initializes each place with n,k,... tokens).
						places = "place | place | ..." are the places from which to take-deposit petri net tokens.
						start = "name" ["content"] of widget to open
		
			#fit.Examples
				:markdown
					## STEP/POST example
					A POST to system X with a state hash of {... reset:1,name:"A"} directs system X to load its 
					input state variable "A" with the contents of the input job stream itau[0].job.  A POST to system X with a state
					hash of {... reset:0,name:"B"} directs X to advance its output variable "B" into each 
					output job stream otau[n].job.
					
					## INIT/PUT example
					
					## FREE/DELETE example
					
					## READ/GET example
			
	#fit.Context.Keys
		:markdown
			The following #{nick}-context keys (current value) are available:
			+	master	URL to master (#{master})  
			+	worker	URL to worker (#{worker})  
			+	socketio	URL to socket.io (#{socketio})  
			+	location client location (#{location})  
			+	org	client organization (#{org})  
			+	email	client email address (#{email})  
			+	client	client name (#{client})  
			+	joined	session start time (#{joined})  
			+	query	request query (#{JSON.stringify(query)})
			+	flags	request flags (#{JSON.stringify(flags)})  
			+	db	database group (#{db})  
			+	source	request dataset, view, or engine (#{source})  
			+	action	request action (#{action})  
			+	distro	email distributions (!{distro})  
			+	profile	client qos profile (#{JSON.stringify(profile)})  
			+	info 	system transition info (#{JSON.stringify(info)})  
			+	title	full site name (#{title})  
			+	nick	site nick name (#{nick})  
			+	ver	site version number (#{ver})  
			+	released	site release date (#{released})  
			+	type	Client type M=moderator, U=nonmoderator (#{type})  
			+	lock	session lock (#{JSON.stringify(options)})
							
			and are referenced with \\#{KEY} (html escaped) or using \\!{KEY} (no html escape).

			Skinning context also include several methods:
			+	get(list,where,index,ag)  
			aggregates a list into a ag=join | table, matching a where={key:value, ...} clause, 
			and indexed on index="key,key,...".

			as well as view-specific \\#{DS.KEY} variables defined at #{nick} startup.

	//- #exsite.Examples(dims="800,500")